% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Flamingo Documentation}
\date{December 17, 2014}
\release{1.0.1}
\author{Bas Hoonhout}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


The Flamingo toolbox is an open-source toolbox for image segmentation, classification and rectification.
It is developed by the Department of Hydraulic Engineering of Delft University of Technology for coastal image analysis.
The toolbox is built around the \emph{scikit-image}, \emph{scikit-learn}, \emph{OpenCV} and \emph{pystruct} toolboxes.

Flamingo is developed and maintained by:

\begin{DUlineblock}{0em}
\item[] Bas Hoonhout \textless{}\href{mailto:b.m.hoonhout@tudelft.nl}{b.m.hoonhout@tudelft.nl}\textgreater{}
\item[] Max Radermacher \textless{}\href{mailto:m.radermacher@tudelft.nl}{m.radermacher@tudelft.nl}\textgreater{}
\end{DUlineblock}


\chapter{Contents}
\label{index:contents}\label{index:welcome-to-flamingo-s-documentation}

\section{Rectification}
\label{rectification:rectification}\label{rectification::doc}
This module provides functions to project an image onto a
real-world coordinate system using ground control points. The
module is largely based on the \emph{OpenCV Camera Calibration and 3D
Reconstruction} workflow and works nicely together with the \emph{argus2}
toolbox for coastal image analysis.

A typical workflow consists of determining ground control points
by measuring the real-world coordinates of object visible in the
image and the image coordinates of these very same objects. Also
the camera matrix and lens distortion parameters should be
determined.

Subsequently, a homography can be determined using the
{\hyperref[rectification:flamingo.rectification.rectification.find_homography]{\code{flamingo.rectification.rectification.find\_homography()}}} function and a projection of the image can be
plotted using the accompanying {\hyperref[rectification:module-flamingo.rectification.plot]{\code{flamingo.rectification.plot}}} module.


\strong{See also:}


\href{http://docs.opencv.org/modules/calib3d/doc/camera\_calibration\_and\_3d\_reconstruction.html}{http://docs.opencv.org/modules/calib3d/doc/camera\_calibration\_and\_3d\_reconstruction.html}




\subsection{Rectification}
\label{rectification:id1}\phantomsection\label{rectification:module-flamingo.rectification.rectification}\index{flamingo.rectification.rectification (module)}\index{find\_homography() (in module flamingo.rectification.rectification)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.rectification.find_homography}\pysiglinewithargsret{\code{flamingo.rectification.rectification.}\bfcode{find\_homography}}{\emph{UV}, \emph{XYZ}, \emph{K}, \emph{distortion=array({[}{[} 0.}, \emph{0.}, \emph{0.}, \emph{0.{]}{]})}, \emph{z=0}}{}
Find homography based on ground control points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{UV} (\emph{np.ndarray}) -- Nx2 array of image coordinates of gcp's

\item {} 
\textbf{XYZ} (\emph{np.ndarray}) -- Nx3 array of real-world coordinates of gcp's

\item {} 
\textbf{K} (\emph{np.ndarray}) -- 3x3 array containing camera matrix

\item {} 
\textbf{distortion} (\emph{np.ndarray, optional}) -- 1xP array with distortion coefficients with P = 4, 5 or 8

\item {} 
\textbf{z} (\emph{float, optional}) -- Real-world elevation on which the image should be projected

\end{itemize}

\item[{Returns}] \leavevmode
3x3 homography matrix

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}
\paragraph{Notes}

Function uses the OpenCV image rectification workflow as described in
\href{http://docs.opencv.org/modules/calib3d/doc/camera\_calibration\_and\_3d\_reconstruction.html}{http://docs.opencv.org/modules/calib3d/doc/camera\_calibration\_and\_3d\_reconstruction.html}
starting with solvePnP.
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{camera\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{argus2}\PYG{o}{.}\PYG{n}{rest}\PYG{o}{.}\PYG{n}{get\PYGZus{}rectification\PYGZus{}data}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{kijkduin}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{H} \PYG{o}{=} \PYG{n}{flamingo}\PYG{o}{.}\PYG{n}{rectification}\PYG{o}{.}\PYG{n}{find\PYGZus{}homography}\PYG{p}{(}\PYG{n}{r}\PYG{p}{[}\PYG{n}{camera\PYGZus{}id}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{UV}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+go}{                                               r[camera\PYGZus{}id][\PYGZsq{}XYZ\PYGZsq{}],}
\PYG{g+go}{                                               r[camera\PYGZus{}id][\PYGZsq{}K\PYGZsq{}])}
\end{Verbatim}

\end{fulllineitems}

\index{get\_pixel\_coordinates() (in module flamingo.rectification.rectification)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.rectification.get_pixel_coordinates}\pysiglinewithargsret{\code{flamingo.rectification.rectification.}\bfcode{get\_pixel\_coordinates}}{\emph{img}}{}
Get pixel coordinates given an image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{img} (\emph{np.ndarray}) -- NxMx1 or NxMx3 image matrix

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{np.ndarray} --
NxM matrix containing u-coordinates

\item {} 
\emph{np.ndarray} --
NxM matrix containing v-coordinates

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{rectify\_coordinates() (in module flamingo.rectification.rectification)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.rectification.rectify_coordinates}\pysiglinewithargsret{\code{flamingo.rectification.rectification.}\bfcode{rectify\_coordinates}}{\emph{U}, \emph{V}, \emph{H}}{}~\begin{description}
\item[{Get projection of image pixels in real-world coordinates}] \leavevmode
given image coordinate matrices and  homography

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{U} (\emph{np.ndarray}) -- NxM matrix containing u-coordinates

\item {} 
\textbf{V} (\emph{np.ndarray}) -- NxM matrix containing v-coordinates

\item {} 
\textbf{H} (\emph{np.ndarray}) -- 3x3 homography matrix

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{np.ndarray} --
NxM matrix containing real-world x-coordinates

\item {} 
\emph{np.ndarray} --
NxM matrix containing real-world y-coordinates

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{rectify\_image() (in module flamingo.rectification.rectification)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.rectification.rectify_image}\pysiglinewithargsret{\code{flamingo.rectification.rectification.}\bfcode{rectify\_image}}{\emph{img}, \emph{H}}{}~\begin{description}
\item[{Get projection of image pixels in real-world coordinates}] \leavevmode
given an image and homography

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{np.ndarray}) -- NxMx1 or NxMx3 image matrix

\item {} 
\textbf{H} (\emph{np.ndarray}) -- 3x3 homography matrix

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{np.ndarray} --
NxM matrix containing real-world x-coordinates

\item {} 
\emph{np.ndarray} --
NxM matrix containing real-world y-coordinates

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsection{Visualization}
\label{rectification:visualization}\label{rectification:module-flamingo.rectification.plot}\index{flamingo.rectification.plot (module)}\index{find\_horizon\_offset() (in module flamingo.rectification.plot)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.plot.find_horizon_offset}\pysiglinewithargsret{\code{flamingo.rectification.plot.}\bfcode{find\_horizon\_offset}}{\emph{x}, \emph{y}, \emph{max\_distance=10000.0}}{}
Find minimum number of pixels to crop to guarantee all pixels are within specified distance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} (\emph{np.ndarray}) -- NxM matrix containing real-world x-coordinates

\item {} 
\textbf{y} (\emph{np.ndarray}) -- NxM matrix containing real-world y-coordinates

\item {} 
\textbf{max\_distance} (\emph{float, optional}) -- Maximum distance from origin to be included in the plot.
Larger numbers are considered to be beyond the horizon.

\end{itemize}

\item[{Returns}] \leavevmode
Minimum crop distance in pixels (from the top of the image)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_coverage() (in module flamingo.rectification.plot)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.plot.plot_coverage}\pysiglinewithargsret{\code{flamingo.rectification.plot.}\bfcode{plot\_coverage}}{\emph{X}, \emph{Y}, \emph{rotation=None}, \emph{translation=None}, \emph{max\_distance=10000.0}, \emph{ax=None}, \emph{figsize=(30}, \emph{20)}, \emph{cmap=\textless{}matplotlib.colors.LinearSegmentedColormap object at 0x114790750\textgreater{}}, \emph{alpha=0.4}}{}
Plot the coverage of the projection of multiple images in a single axis.

Plot the outline of lists of real-world x and y coordinate
matrices. The resulting composition can be rotated and
translated seperately.

Points projected at infinite distance can be ignored by
specifying a maximum distance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{list of np.ndarrays}) -- List of NxM matrix containing real-world x-coordinates

\item {} 
\textbf{Y} (\emph{list of np.ndarrays}) -- List of NxM matrix containing real-world y-coordinates

\item {} 
\textbf{rotation} (\emph{float, optional}) -- Rotation angle in degrees

\item {} 
\textbf{translation} (\emph{list or tuple, optional}) -- 2-tuple or list with x and y translation distances

\item {} 
\textbf{max\_distance} (\emph{float, optional}) -- Maximum distance from origin to be included in the plot.
Larger numbers are considered to be beyond the horizon.

\item {} 
\textbf{ax} (\emph{matplotlib.axes.AxesSubplot, optional}) -- Axis object used for plotting

\item {} 
\textbf{figsize} (\emph{tuple, optional}) -- 2-tuple or list containing figure dimensions

\item {} 
\textbf{cmap} (\emph{matplotlib.colors.Colormap, optional}) -- Colormap to determine colors for individual patches

\item {} 
\textbf{alpha} (\emph{float, optional}) -- Alpha value for patches

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{matplotlib.figure.Figure} --
Figure object containing axis object

\item {} 
\emph{matplotlib.axes.AxesSubplot} --
Axis object containing plot

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_rectified() (in module flamingo.rectification.plot)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.plot.plot_rectified}\pysiglinewithargsret{\code{flamingo.rectification.plot.}\bfcode{plot\_rectified}}{\emph{X}, \emph{Y}, \emph{imgs}, \emph{rotation=None}, \emph{translation=None}, \emph{max\_distance=10000.0}, \emph{ax=None}, \emph{figsize=(30}, \emph{20)}, \emph{cmap='Greys'}, \emph{color=True}, \emph{n\_alpha=0}}{}
Plot the projection of multiple RGB images in a single axis.

Plot a list of images using corresponding lists of real-world
x and y coordinate matrices. The resulting composition can be
rotated and translated seperately.

Points projected at infinite distance can be ignored by
specifying a maximum distance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{list of np.ndarrays}) -- List of NxM matrix containing real-world x-coordinates

\item {} 
\textbf{Y} (\emph{list of np.ndarrays}) -- List of NxM matrix containing real-world y-coordinates

\item {} 
\textbf{imgs} (\emph{list of np.ndarrays}) -- List of NxMx1 or NxMx3 image matrices

\item {} 
\textbf{rotation} (\emph{float, optional}) -- Rotation angle in degrees

\item {} 
\textbf{translation} (\emph{list or tuple, optional}) -- 2-tuple or list with x and y translation distances

\item {} 
\textbf{max\_distance} (\emph{float, optional}) -- Maximum distance from origin to be included in the plot.
Larger numbers are considered to be beyond the horizon.

\item {} 
\textbf{ax} (\emph{matplotlib.axes.AxesSubplot, optional}) -- Axis object used for plotting

\item {} 
\textbf{figsize} (\emph{tuple, optional}) -- 2-tuple or list containing figure dimensions

\item {} 
\textbf{color} (\emph{bool, optional}) -- Whether color image should be plotted or grayscale

\item {} 
\textbf{n\_alpha} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- Number of border pixels to use to increase alpha

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{matplotlib.figure.Figure} --
Figure object containing axis object

\item {} 
\emph{matplotlib.axes.AxesSubplot} --
Axis object containing plot

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{rotate\_translate() (in module flamingo.rectification.plot)}

\begin{fulllineitems}
\phantomsection\label{rectification:flamingo.rectification.plot.rotate_translate}\pysiglinewithargsret{\code{flamingo.rectification.plot.}\bfcode{rotate\_translate}}{\emph{x}, \emph{y}, \emph{rotation=None}, \emph{translation=None}}{}
Rotate and/or translate coordinate system
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{x} (\emph{np.ndarray}) -- NxM matrix containing x-coordinates

\item {} 
\textbf{y} (\emph{np.ndarray}) -- NxM matrix containing y-coordinates

\item {} 
\textbf{rotation} (\emph{float, optional}) -- Rotation angle in degrees

\item {} 
\textbf{translation} (\emph{list or tuple, optional}) -- 2-tuple or list with x and y translation distances

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{np.ndarrays} --
NxM matrix containing rotated/translated x-coordinates

\item {} 
\emph{np.ndarrays} --
NxM matrix containing rotated/translated y-coordinates

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{Segmentation}
\label{segmentation:segmentation}\label{segmentation::doc}
This module provides functions to segmentate an image into
superpixels. It is largely based on the \emph{scikit-image} toolbox.
Apart from the regular segmentation functions it provides
postprocessing functions to ensure connected segments in a regular
grid. It also provides various visualization tools for segmented
images.


\strong{See also:}


\href{http://scikit-image.org/docs/0.10.x/api/skimage.segmentation.html}{http://scikit-image.org/docs/0.10.x/api/skimage.segmentation.html}




\subsection{Superpixels}
\label{segmentation:superpixels}\label{segmentation:module-flamingo.segmentation.superpixels}\index{flamingo.segmentation.superpixels (module)}\index{average\_colors() (in module flamingo.segmentation.superpixels)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.superpixels.average_colors}\pysiglinewithargsret{\code{flamingo.segmentation.superpixels.}\bfcode{average\_colors}}{\emph{img}, \emph{segments}}{}
Average colors per superpixels

Returns an image where each pixel has the average color of the
superpixel that it belongs to.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{np.ndarray}) -- NxM or NxMx3 array with greyscale or colored image information
respectively

\item {} 
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\end{itemize}

\item[{Returns}] \leavevmode
NxM or NxMx3 matrix with averaged image

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_segmentation() (in module flamingo.segmentation.superpixels)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.superpixels.check_segmentation}\pysiglinewithargsret{\code{flamingo.segmentation.superpixels.}\bfcode{check\_segmentation}}{\emph{segments}, \emph{nx}, \emph{ny}}{}
Checks if segmentation data is complete

Checks if the segmentation data indeed contains nx*ny segments and
if the set of segment numbers is continuous.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item {} 
\textbf{ny} (\emph{nx,}) -- Size of supposed segmentation grid

\end{itemize}

\item[{Returns}] \leavevmode
Returns true if segmentation is valid and false otherwise

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_contours() (in module flamingo.segmentation.superpixels)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.superpixels.get_contours}\pysiglinewithargsret{\code{flamingo.segmentation.superpixels.}\bfcode{get\_contours}}{\emph{segments}}{}
Return contours of superpixels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item[{Returns}] \leavevmode
list of lists for each segment in \emph{segments}. Each segment
list contains one or more contours. Each contour is defined by
a list of 2-tuples with an x and y coordinate.

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{contours} \PYG{o}{=} \PYG{n}{get\PYGZus{}contours}\PYG{p}{(}\PYG{n}{segments}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot}\PYG{p}{(}\PYG{n}{contours}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{contours}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} plot first contour of first segment}
\end{Verbatim}

\end{fulllineitems}

\index{get\_segmentation() (in module flamingo.segmentation.superpixels)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.superpixels.get_segmentation}\pysiglinewithargsret{\code{flamingo.segmentation.superpixels.}\bfcode{get\_segmentation}}{\emph{img}, \emph{method='slic'}, \emph{method\_params=\{\}}, \emph{extract\_contours=False}, \emph{remove\_disjoint=True}}{}
Return segmentation of image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{np.ndarray}) -- NxM or NxMx3 array with greyscale or colored image information
respectively

\item {} 
\textbf{method} (\emph{str, optional}) -- Segmentation method to use, supported by scikit-image toolbox

\item {} 
\textbf{method\_params} (\emph{dict, optional}) -- Extra parameters supplied to segmentation method

\item {} 
\textbf{extract\_contours} (\emph{bool, optional}) -- Also extract contours of segments

\item {} 
\textbf{remove\_disjoint} (\emph{bool, optional}) -- Ensure that the output contains connected segments only
\textbf{and} that the superpixels form a more or less regular grid.
In case the segmentation method does not provide both
constraints, the constraint is ensured in a postprocessing
step.

\end{itemize}

\item[{Returns}] \leavevmode
NxM matrix with segment numbering

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{img} \PYG{o}{=} \PYG{n}{argus2}\PYG{o}{.}\PYG{n}{rest}\PYG{o}{.}\PYG{n}{get\PYGZus{}image}\PYG{p}{(}\PYG{n}{station}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{kijkduin}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{segments} \PYG{o}{=} \PYG{n}{get\PYGZus{}segmentation}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{get\_superpixel\_grid() (in module flamingo.segmentation.superpixels)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.superpixels.get_superpixel_grid}\pysiglinewithargsret{\code{flamingo.segmentation.superpixels.}\bfcode{get\_superpixel\_grid}}{\emph{segments}, \emph{img\_shape}}{}
Return shape of superpixels grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item {} 
\textbf{img\_shape} (\emph{2-tuple or list}) -- Dimensions of image

\end{itemize}

\item[{Returns}] \leavevmode
tuple containing M and N dimension of regular superpixel grid

\item[{Return type}] \leavevmode
2-tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{shuffle\_pixels() (in module flamingo.segmentation.superpixels)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.superpixels.shuffle_pixels}\pysiglinewithargsret{\code{flamingo.segmentation.superpixels.}\bfcode{shuffle\_pixels}}{\emph{img}}{}
Shuffle class identifiers
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{img} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item[{Returns}] \leavevmode
NxM matrix with shuffled segment numbering

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seg} \PYG{o}{=} \PYG{n}{get\PYGZus{}segmentation}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{seg}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{shuffle\PYGZus{}pixels}\PYG{p}{(}\PYG{n}{seg}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\subsection{Postprocessing}
\label{segmentation:module-flamingo.segmentation.postprocess}\label{segmentation:postprocessing}\index{flamingo.segmentation.postprocess (module)}\index{region\_growing() (in module flamingo.segmentation.postprocess)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.postprocess.region_growing}\pysiglinewithargsret{\code{flamingo.segmentation.postprocess.}\bfcode{region\_growing}}{\emph{mask}, \emph{connectivity=8}}{}
Simple region growing algorithm
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{mask} (\emph{np.ndarray}) -- Binary matrix indicating what pixels are within a region and
what are not

\item {} 
\textbf{connectivity} (\emph{int, 4 or 8}) -- Number of neighbouring pixels taken into account

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{list} --
List of 2-tuples with coordinates within a region

\item {} 
\emph{list} --
List of 2-tuples with coordinates at the edge of the region

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{regularize() (in module flamingo.segmentation.postprocess)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.postprocess.regularize}\pysiglinewithargsret{\code{flamingo.segmentation.postprocess.}\bfcode{regularize}}{\emph{segments}, \emph{nx}, \emph{ny}}{}
Create a regular grid from a collection of image segments

The number of segments supplied is supposed to be larger than the
number of segments in the target grid (nx*ny). A regular grid of
size nx*ny over the image grid NxM is constructed. Subsequently,
the segments are ordered based on size. the nx*ny largest segments
are preserved and assigned to a single grid cell in the regular
grid based on least squares fit. The smaller segments are added to
the preserved segment that is closest based on their centroids.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item {} 
\textbf{ny} (\emph{nx,}) -- Dimensions of the target superpixel grid

\end{itemize}

\item[{Returns}] \leavevmode
NxM matrix with alternative segment numbering with segments in
a regular grid

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_disjoint() (in module flamingo.segmentation.postprocess)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.postprocess.remove_disjoint}\pysiglinewithargsret{\code{flamingo.segmentation.postprocess.}\bfcode{remove\_disjoint}}{\emph{segments}}{}
Remove disjoint regions in segmentation

Remove disjoint regions in segmentation by running a region
growing algorihtm for each segment. Any segment that appears to
consist out of multiple disconnected parts is splitted. The
biggest part remains as placeholder of the existing superpixel.
The smaller parts are joined with the neighbouring superpixels.
If multiple neighbouring superpixels exist, the one that shares
the largest border is chosen.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item[{Returns}] \leavevmode
NxM matrix with alternative segment numbering with connected
segments

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Visualization}
\label{segmentation:module-flamingo.segmentation.plot}\label{segmentation:visualization}\index{flamingo.segmentation.plot (module)}\index{get\_image\_data() (in module flamingo.segmentation.plot)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.plot.get_image_data}\pysiglinewithargsret{\code{flamingo.segmentation.plot.}\bfcode{get\_image\_data}}{\emph{fig}, \emph{dpi=96}, \emph{axis\_only=True}, \emph{transparent=True}}{}
Get binary image data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fig} (\emph{matplotlib.figure.Figure}) -- Figure object containing axis object

\item {} 
\textbf{dpi} (\emph{int, optional}) -- Image resolution

\item {} 
\textbf{axis\_only} (\emph{bool, optional}) -- Only include contents of axis

\item {} 
\textbf{transparent} (\emph{bool, optional}) -- Plot background transparent

\end{itemize}

\item[{Returns}] \leavevmode
Binary image data

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{plot() (in module flamingo.segmentation.plot)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.plot.plot}\pysiglinewithargsret{\code{flamingo.segmentation.plot.}\bfcode{plot}}{\emph{img}, \emph{segments}, \emph{mark\_boundaries=True}, \emph{shuffle=False}, \emph{average=False}, \emph{slice=1}, \emph{raw=False}}{}
Plot segmentation result
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{np.ndarray}) -- NxM or NxMx3 array with greyscale or colored image information
respectively

\item {} 
\textbf{segments} (\emph{np.ndarray}) -- NxM matrix with segment numbering

\item {} 
\textbf{mark\_boundaries} (\emph{bool, optional}) -- Draw boundaries in image

\item {} 
\textbf{shuffle} (\emph{bool, optional}) -- Shuffle segment numbering for more scattered coloring (ignored
when \emph{average} is used)

\item {} 
\textbf{average} (\emph{bool, optional}) -- Average colors per segment

\item {} 
\textbf{slice} (\emph{int, optional}) -- Use slice to reduce the image size

\item {} 
\textbf{raw} (\emph{bool, optional}) -- Return raw binary output

\end{itemize}

\item[{Returns}] \leavevmode
Binary image data or 2-tuple with matplotlib.figure.Figure and
matplotlib.axes.AxesSubplot objects

\item[{Return type}] \leavevmode
str or 2-tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_image() (in module flamingo.segmentation.plot)}

\begin{fulllineitems}
\phantomsection\label{segmentation:flamingo.segmentation.plot.plot_image}\pysiglinewithargsret{\code{flamingo.segmentation.plot.}\bfcode{plot\_image}}{\emph{img}, \emph{cmap='Set2'}, \emph{dpi=96}, \emph{slice=0}, \emph{transparent=True}, \emph{raw=False}}{}
Get binary image data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{np.ndarray}) -- NxM or NxMx3 array with greyscale or colored image information
respectively

\item {} 
\textbf{cmap} (\emph{matplotlib.colors.Colormap, optional}) -- Colormap to determine colors for individual patches

\item {} 
\textbf{dpi} (\emph{int, optional}) -- Image resolution

\item {} 
\textbf{slice} (\emph{int, optional}) -- Use slice to reduce the image size

\item {} 
\textbf{transparent} (\emph{bool, optional}) -- Plot background transparent

\item {} 
\textbf{raw} (\emph{bool, optional}) -- Return raw binary output

\end{itemize}

\item[{Returns}] \leavevmode
Binary image data or 2-tuple with matplotlib.figure.Figure and
matplotlib.axes.AxesSubplot objects

\item[{Return type}] \leavevmode
str or 2-tuple

\end{description}\end{quote}

\end{fulllineitems}



\section{Classification}
\label{classification::doc}\label{classification:classification}
This module provides functions to train image classification models, like Logistic Regressors and Conditional Random Fields.
It provides functions for feature extraction that are largely based on the \emph{scikit-image} toolbox and
it provides functions for model training and optimization that are largely based on the \emph{pystruct} and \emph{scikit-learn} toolbox.


\strong{See also:}


\href{http://scikit-image.org/docs/0.10.x/api/skimage.feature.html}{http://scikit-image.org/docs/0.10.x/api/skimage.feature.html}




\strong{See also:}


\href{http://scikit-learn.org/stable/modules/classes.html\#module-sklearn.linear\_model}{http://scikit-learn.org/stable/modules/classes.html\#module-sklearn.linear\_model}




\strong{See also:}


\href{https://pystruct.github.io/references.html}{https://pystruct.github.io/references.html}




\subsection{Models}
\label{classification:models}\label{classification:module-flamingo.classification.models}\index{flamingo.classification.models (module)}\index{ConditionalRandomField (class in flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.ConditionalRandomField}\pysiglinewithargsret{\strong{class }\code{flamingo.classification.models.}\bfcode{ConditionalRandomField}}{\emph{model}, \emph{max\_iter=10000}, \emph{C=1.0}, \emph{check\_constraints=False}, \emph{verbose=0}, \emph{negativity\_constraint=None}, \emph{n\_jobs=1}, \emph{break\_on\_bad=False}, \emph{show\_loss\_every=0}, \emph{tol=0.001}, \emph{inference\_cache=0}, \emph{inactive\_threshold=1e-05}, \emph{inactive\_window=50}, \emph{logger=None}, \emph{cache\_tol='auto'}, \emph{switch\_to=None}, \emph{clist=None}}{}
Conditional Random Field

Equal to \code{pystruct.learners.OneSlackSSVM} (inherited), but
also takes string class labels as input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{clist} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with possible class names

\end{description}\end{quote}
\paragraph{Notes}

Only arguments additional to \code{pystruct.learners.OneSlackSSVM} are listed.

\end{fulllineitems}

\index{ConditionalRandomFieldPerceptron (class in flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.ConditionalRandomFieldPerceptron}\pysiglinewithargsret{\strong{class }\code{flamingo.classification.models.}\bfcode{ConditionalRandomFieldPerceptron}}{\emph{model}, \emph{max\_iter=100}, \emph{verbose=0}, \emph{batch=False}, \emph{decay\_exponent=0.0}, \emph{decay\_t0=0.0}, \emph{average=False}, \emph{clist=None}}{}
Conditional Random Field

Equal to \code{pystruct.learners.StructuredPerceptron}
(inherited), but also takes string class labels as input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{clist} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with possible class names

\end{description}\end{quote}
\paragraph{Notes}

Only arguments additional to \code{pystruct.learners.StrcturedPerceptron} are listed.

\end{fulllineitems}

\index{LogisticRegression (class in flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.LogisticRegression}\pysiglinewithargsret{\strong{class }\code{flamingo.classification.models.}\bfcode{LogisticRegression}}{\emph{penalty='l2'}, \emph{dual=False}, \emph{tol=0.0001}, \emph{C=1.0}, \emph{fit\_intercept=True}, \emph{intercept\_scaling=1}, \emph{class\_weight=None}, \emph{random\_state=None}}{}
Logistic Regressor

Equal to \code{sklearn.linear\_model.LogisticRegression}
(inherited), but also takes non-linearized structured data as
input.

\end{fulllineitems}

\index{LogisticRegressionRLP (class in flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.LogisticRegressionRLP}\pysiglinewithargsret{\strong{class }\code{flamingo.classification.models.}\bfcode{LogisticRegressionRLP}}{\emph{penalty='l2'}, \emph{dual=False}, \emph{tol=0.0001}, \emph{C=1.0}, \emph{fit\_intercept=True}, \emph{intercept\_scaling=1}, \emph{class\_weight=None}, \emph{random\_state=None}, \emph{rlp\_maps=None}, \emph{rlp\_stats=None}}{}
Logistic Regressor with support for Relative Location Priors

Equal to {\hyperref[classification:flamingo.classification.models.LogisticRegression]{\code{flamingo.classification.models.LogisticRegression}}}
(inherited), but supports the use of Relative Location Priors as
proposed by {\hyperref[classification:gould2008]{{[}Gould2008{]}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{rlp\_maps} (\href{http://docs.python.org/library/stdtypes.html\#dict}{\emph{dict}}) -- Dictionary with for each class an np.ndarray with a relative
location map

\item {} 
\textbf{rlp\_stats} (\href{http://docs.python.org/library/stdtypes.html\#dict}{\emph{dict}}) -- Dictionary with for each relative location feature a mean and
standard deviation for normalizing to standard normal space

\end{itemize}

\end{description}\end{quote}
\paragraph{Notes}

Only arguments additional to {\hyperref[classification:flamingo.classification.models.LogisticRegression]{\code{flamingo.classification.models.LogisticRegression}}} are listed.

\end{fulllineitems}

\index{SupportVectorMachine (class in flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.SupportVectorMachine}\pysiglinewithargsret{\strong{class }\code{flamingo.classification.models.}\bfcode{SupportVectorMachine}}{\emph{penalty='l2'}, \emph{loss='l2'}, \emph{dual=True}, \emph{tol=0.0001}, \emph{C=1.0}, \emph{multi\_class='ovr'}, \emph{fit\_intercept=True}, \emph{intercept\_scaling=1}, \emph{class\_weight=None}, \emph{verbose=0}, \emph{random\_state=None}}{}
Support Vecor Machine

Equal to \code{sklearn.svm.LinearSVC} (inherited), but also
takes non-linearized structured data as input.

\end{fulllineitems}

\index{get\_model() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.get_model}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{get\_model}}{\emph{model\_type='LR'}, \emph{n\_states=None}, \emph{n\_features=None}, \emph{rlp\_maps=None}, \emph{rlp\_stats=None}, \emph{C=1.0}}{}
Returns a bare model object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{model\_type} (\emph{string, optional}) -- String indicating the type of model to be constructed.
LR = Logistic Regressor (default), LR\_RLP = Logistic Regressor with Relative Location Prior, SVM = Support Vector Machine, CRF = Conditional Random Field

\item[{Returns}] \leavevmode
Bare model object

\item[{Return type}] \leavevmode
object

\item[{Other Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{n\_states} (\emph{integer}) --
Number of classes (CRF only)

\item {} 
\textbf{n\_features} (\emph{integer}) --
Number of features (CRF only)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{predict\_model() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.predict_model}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{predict\_model}}{\emph{model}, \emph{X}}{}
Run class prediction of image with a single model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{model} (\href{http://docs.python.org/library/functions.html\#object}{\emph{object}}) -- Trained model object. Model object should have a score() method.

\item {} 
\textbf{X} (\emph{list or numpy.ndarray}) -- 2D array containing training data.
Each row is a training instance, while each column is a feature.

\end{itemize}

\item[{Returns}] \leavevmode
Class prediction for image

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{predict\_models() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.predict_models}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{predict\_models}}{\emph{models}, \emph{sets}}{}
Run class predictions for a set of trained models and corresponding data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{models} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of lists with each item a trained instance of a model.

\item {} 
\textbf{sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing data corresponding to the model list.

\end{itemize}

\item[{Returns}] \leavevmode
List of lists containing np.ndarrays with class predictions for each
image and each model.

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}
\paragraph{Notes}

Models should be trained.
Model and set lists should be of equal length.
In case of N models and M training sets the models should be
organized in a N-length list of M-length lists.

\end{fulllineitems}

\index{score\_model() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.score_model}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{score\_model}}{\emph{model}, \emph{X\_train}, \emph{Y\_train}, \emph{X\_test}, \emph{Y\_test}}{}
Scores a single model using a train and test set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{model} (\href{http://docs.python.org/library/functions.html\#object}{\emph{object}}) -- Trained model object. Model object should have a score() method.

\item {} 
\textbf{X\_train} (\emph{list or numpy.ndarray}) -- 2D array containing training data.
Each row is a training instance, while each column is a feature.

\item {} 
\textbf{Y\_train} (\emph{list or numpy.ndarray}) -- Array containing class annotations for each training instance.

\item {} 
\textbf{X\_test} (\emph{Similar to X\_train, but with test data.}) -- 

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{score\_train} (\emph{float}) --
Training score

\item {} 
\textbf{score\_test} (\emph{float}) --
Test score

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{score\_models() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.score_models}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{score\_models}}{\emph{models}, \emph{train\_sets}, \emph{test\_sets}, \emph{**kwargs}}{}
Compute train/test scores for a set of trained models
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{models} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of lists with each item a trained instance of a model.

\item {} 
\textbf{train\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing training data corresponding to the
model list.

\item {} 
\textbf{test\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing test data corresponding to the model
list.

\item {} 
\textbf{**kwargs} -- 
Additional arguments passed to the scoring function


\end{itemize}

\item[{Returns}] \leavevmode
MultiIndex DataFrame containing training and test scores.
Indices ``model'' and ``set'' indicate the model and training set number used.
Columns ``train'' and ``test'' contain the train and test scores respectively.

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}
\paragraph{Notes}

Models should be trained.
Model and set lists should be of equal length.
In case of N models and M training sets the models should be
organized in a N-length list of M-length lists. The train and test
sets should both be M-length lists.
\paragraph{Examples}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{models} \PYG{o}{=} \PYG{p}{[}\PYG{n}{models}\PYG{o}{.}\PYG{n}{get\PYGZus{}model}\PYG{p}{(}\PYG{n}{model\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{g+go}{              models.get\PYGZus{}model(model\PYGZus{}type=\PYGZsq{}CRF\PYGZsq{}, n\PYGZus{}states=5, n\PYGZus{}features=10)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{models\PYGZus{}trained} \PYG{o}{=} \PYG{n}{models}\PYG{o}{.}\PYG{n}{train\PYGZus{}models}\PYG{p}{(}\PYG{n}{models}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{Y\PYGZus{}train}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores} \PYG{o}{=} \PYG{n}{test}\PYG{o}{.}\PYG{n}{score\PYGZus{}models}\PYG{p}{(}\PYG{n}{models}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{Y\PYGZus{}train}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{,} \PYG{n}{Y\PYGZus{}test}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{train\_model() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.train_model}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{train\_model}}{\emph{model}, \emph{X\_train}, \emph{Y\_train}, \emph{X\_train\_prior=None}}{}
Trains a single model against a single training set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{model} (\href{http://docs.python.org/library/functions.html\#object}{\emph{object}}) -- Bare model object. Model object should hava a fit() method.

\item {} 
\textbf{X\_train} (\emph{list or numpy.ndarray}) -- 2D array containing training data. Each row is a training
instance, while each column is a feature.

\item {} 
\textbf{Y\_train} (\emph{list or numpy.ndarray}) -- Array containing class annotations for each training instance.

\item {} 
\textbf{X\_train\_prior} (\emph{list or numpy.ndarray, optional}) -- 2D array containing prior data. Each row is a training
instance, while each column is a feature.

\end{itemize}

\end{description}\end{quote}
\paragraph{Notes}

Models are passed by reference and trained without copying.

\end{fulllineitems}

\index{train\_models() (in module flamingo.classification.models)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.models.train_models}\pysiglinewithargsret{\code{flamingo.classification.models.}\bfcode{train\_models}}{\emph{models}, \emph{train\_sets}, \emph{prior\_sets=None}, \emph{callback=None}}{}
Trains a set of model against a series of training sets
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{models} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of model objects. Model objects should have a fit() method.

\item {} 
\textbf{train\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing training data. The first item in a
tuple is a 2D array. Each row is a training instance, while
each column is a feature. The second item in a tuple is an
array containing class annotations for each training instance.

\item {} 
\textbf{prior\_sets} (\emph{list, optional}) -- List of 2D arrays containing prior data. Similar to first
tuple item in train\_sets. Each item is a 2D array. Each row is
a training instance, while each column is a feature.

\item {} 
\textbf{callback} (\emph{function, optional}) -- Callback function that is called after training of a model
finished. Function accepts two parameters: the model object
and a tuple with location indices in the resulting model
matrix.

\end{itemize}

\item[{Returns}] \leavevmode
List of lists with each item a trained instance of one of the models.

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Features}
\label{classification:module-flamingo.classification.features.features}\label{classification:features}\index{flamingo.classification.features.features (module)}\index{linearize() (in module flamingo.classification.features.features)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.features.features.linearize}\pysiglinewithargsret{\code{flamingo.classification.features.features.}\bfcode{linearize}}{\emph{features}}{}
convert all items in each matrix feature into individual features

\end{fulllineitems}

\phantomsection\label{classification:module-flamingo.classification.features.blocks}\index{flamingo.classification.features.blocks (module)}\index{extract\_blocks() (in module flamingo.classification.features.blocks)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.features.blocks.extract_blocks}\pysiglinewithargsret{\code{flamingo.classification.features.blocks.}\bfcode{extract\_blocks}}{\emph{data}, \emph{segments}, \emph{colorspace='rgb'}, \emph{blocks=None}, \emph{blocks\_params=\{\}}}{}
Extract all blocks in right order

\end{fulllineitems}

\index{list\_blocks() (in module flamingo.classification.features.blocks)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.features.blocks.list_blocks}\pysiglinewithargsret{\code{flamingo.classification.features.blocks.}\bfcode{list\_blocks}}{}{}
List all block extraction functions in module

\end{fulllineitems}

\phantomsection\label{classification:module-flamingo.classification.features.scaleinvariant}\index{flamingo.classification.features.scaleinvariant (module)}\phantomsection\label{classification:module-flamingo.classification.features.normalize}\index{flamingo.classification.features.normalize (module)}\phantomsection\label{classification:module-flamingo.classification.features.relativelocation}\index{flamingo.classification.features.relativelocation (module)}\index{compute\_prior() (in module flamingo.classification.features.relativelocation)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.features.relativelocation.compute_prior}\pysiglinewithargsret{\code{flamingo.classification.features.relativelocation.}\bfcode{compute\_prior}}{\emph{annotations}, \emph{centroids}, \emph{image\_size}, \emph{superpixel\_grid}, \emph{n=100}}{}
Compute relative location prior according to Gould et al. (2008)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{ds} (\href{http://docs.python.org/library/string.html\#module-string}{\emph{string}}) -- String indicating the dataset to be used.

\item[{Returns}] \leavevmode
\textbf{maps} --
4D panel containing the relative location prior maps: maps{[}\textless{}other class\textgreater{}{]}{[}\textless{}given class\textgreater{}{]}
gives a n*n dataframe representing the dimensionless image map

\item[{Return type}] \leavevmode
pandas.Panel4D

\item[{Other Parameters}] \leavevmode
\textbf{n} (\emph{integer}) --
Half the size of the dimensionless image map

\end{description}\end{quote}

\end{fulllineitems}

\index{smooth\_maps() (in module flamingo.classification.features.relativelocation)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.features.relativelocation.smooth_maps}\pysiglinewithargsret{\code{flamingo.classification.features.relativelocation.}\bfcode{smooth\_maps}}{\emph{maps}, \emph{sigma=2}}{}
Convolve relative location prior maps with a gaussian filter for smoothing purposes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{ds} (\href{http://docs.python.org/library/string.html\#module-string}{\emph{string}}) -- String indicating the dataset to be used.

\item {} 
\textbf{maps} (\emph{pandas.Panel4D}) -- 4D panel containing the relative location prior maps: maps{[}\textless{}other class\textgreater{}{]}{[}\textless{}given class\textgreater{}{]}
gives a n*n dataframe representing the dimensionless image map

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{maps} --
4D panel containing the smoothed relative location prior maps.

\item[{Return type}] \leavevmode
pandas.Panel4D

\item[{Other Parameters}] \leavevmode
\textbf{sigma} (\emph{integer}) --
Size of the gaussian kernel that is to be convolved with the relative location prior maps

\end{description}\end{quote}

\end{fulllineitems}

\index{vote\_image() (in module flamingo.classification.features.relativelocation)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.features.relativelocation.vote_image}\pysiglinewithargsret{\code{flamingo.classification.features.relativelocation.}\bfcode{vote\_image}}{\emph{Y}, \emph{maps}, \emph{centroids=None}, \emph{img\_size=None}, \emph{winner\_takes\_all\_mode=False}}{}
Class voting based on 1st order prediction and relative location prior maps
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{ds} (\href{http://docs.python.org/library/string.html\#module-string}{\emph{string}}) -- String indicating the dataset to be used.

\item {} 
\textbf{Ipred} (\emph{list of lists of tuple of lists of arrays with size {[}n\_models{]}{[}n\_partitions{]}(training,testing){[}n\_images{]}}) -- Arrays contain the 1st order prediction of the labelled images.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{votes} (\emph{pandas.Panel}) --
Panel containing the votes for all classes and superpixels: maps{[}\textless{}class\textgreater{}{]}
gives a nx*ny dataframe representing the probability of every superpixel to be \textless{}class\textgreater{}

\item {} 
\textbf{Ivote} (\emph{np.array}) --
Labelled image based on classes in votes with maximum probability for every superpixel

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsection{Channels}
\label{classification:channels}\label{classification:module-flamingo.classification.channels}\index{flamingo.classification.channels (module)}\index{add\_channels() (in module flamingo.classification.channels)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.channels.add_channels}\pysiglinewithargsret{\code{flamingo.classification.channels.}\bfcode{add\_channels}}{\emph{img, colorspace='rgb', methods={[}'gabor', `gaussian', `sobel'{]}, methods\_params=None}}{}
Add artificial channels to an image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{np.ndarray}) -- NxMx3 array with colored image data

\item {} 
\textbf{colorspace} (\emph{str, optional}) -- String indicating colorspace of \emph{img} (rgb/hsv/etc.)

\item {} 
\textbf{methods} (\emph{list, optional}) -- List of strings indicating channels to be added

\item {} 
\textbf{methods\_params} (\emph{dict, optional}) -- Dictionairy with named options for channel functions

\end{itemize}

\end{description}\end{quote}
\paragraph{Notes}

Currently implemented channels are:
* gabor, with options \emph{frequencies} and \emph{thetas}
* gaussian, with option \emph{sigmas}
* sobel, without any options
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
NxMx(3+P) array with image data with extra channels where P
is the number of channels added

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_channel\_bounds() (in module flamingo.classification.channels)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.channels.get_channel_bounds}\pysiglinewithargsret{\code{flamingo.classification.channels.}\bfcode{get\_channel\_bounds}}{\emph{methods={[}'gabor', `gaussian', `sobel'{]}, methods\_params=None}}{}
Get theoretical bounds of channel values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{methods} (\emph{list, optional}) -- List of strings indicating channels to be added

\item {} 
\textbf{methods\_params} (\emph{dict, optional}) -- Dictionairy with named options for channel functions

\end{itemize}

\item[{Returns}] \leavevmode
List of dicts with keys \emph{min} and \emph{max} indicating the
theoretical boundaries of the channel values

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_number\_channels() (in module flamingo.classification.channels)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.channels.get_number_channels}\pysiglinewithargsret{\code{flamingo.classification.channels.}\bfcode{get\_number\_channels}}{\emph{methods={[}'gabor', `gaussian', `sobel'{]}, methods\_params=None}}{}
Get number of artificial channels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{methods} (\emph{list, optional}) -- List of strings indicating channels to be added

\item {} 
\textbf{methods\_params} (\emph{dict, optional}) -- Dictionairy with named options for channel functions

\end{itemize}

\item[{Returns}] \leavevmode
Number of channels added when using the specified settings

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{normalize\_channel() (in module flamingo.classification.channels)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.channels.normalize_channel}\pysiglinewithargsret{\code{flamingo.classification.channels.}\bfcode{normalize\_channel}}{\emph{channel}, \emph{channelstats}}{}
Scale channel to uint8 based on maximum possible filter response
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{channel} (\emph{np.ndarray}) -- Array with channel values

\item {} 
\textbf{channelstats} (\href{http://docs.python.org/library/stdtypes.html\#dict}{\emph{dict}}) -- Dictionary with fields \emph{min} and \emph{max} indicating the channel
value bounds of the dataset and used for normalization

\end{itemize}

\item[{Returns}] \leavevmode
Array with normalized channel values

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Test}
\label{classification:test}\label{classification:module-flamingo.classification.test}\index{flamingo.classification.test (module)}\index{aggregate\_scores() (in module flamingo.classification.test)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.test.aggregate_scores}\pysiglinewithargsret{\code{flamingo.classification.test.}\bfcode{aggregate\_scores}}{\emph{scores}}{}
Aggregate model scores over training and test sets
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{scores} (\emph{pandas.DataFrame}) -- DataFrame with test scores for different models and training sets.
Should have at least one level index names ``model''.

\item[{Returns}] \leavevmode
DataFrame averaged over all indices except ``model''.

\item[{Return type}] \leavevmode
pandas.DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_learning\_curve() (in module flamingo.classification.test)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.test.compute_learning_curve}\pysiglinewithargsret{\code{flamingo.classification.test.}\bfcode{compute\_learning\_curve}}{\emph{models}, \emph{train\_sets}, \emph{test\_sets}, \emph{step=10}, \emph{**kwargs}}{}
Computes learning curves for combinations of models and training/test sets
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{models} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of model objects. Model objects should have a fit() and score() method.

\item {} 
\textbf{train\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing training data corresponding to the model list.

\item {} 
\textbf{test\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing test data corresponding to the model list.

\item {} 
\textbf{step} (\emph{integer, optional}) -- Step size of learning curve (default: 10)

\item {} 
\textbf{**kwargs} -- 
All other named arguments are redirected to the function models.train\_models()


\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\textbf{all\_scores} (\emph{pandas.DataFrame}) --
MultiIndex DataFrame containing training and test scores.
Indices ``model'' and ``set'' indicate the model and training set number used.
Index ``n'' indicates the number of samples used during training.
Columns ``train'' and ``test'' contain the train and test scores respectively.

\item {} 
\textbf{all\_models} (\emph{list}) --
List with trained models.
Each item corresponds to a single point on the learning curve and
\begin{quote}

can consist of several models organized in a NxM matrix where
N is the original number of models trained and M is the number
of training sets used.
\end{quote}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_learning\_curve() (in module flamingo.classification.test)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.test.plot_learning_curve}\pysiglinewithargsret{\code{flamingo.classification.test.}\bfcode{plot\_learning\_curve}}{\emph{scores}, \emph{ylim=(0.75}, \emph{1)}, \emph{filename=None}}{}
Plots learning curves
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{scores} (\emph{pandas.DataFrame}) -- DataFrame containing all scores used to plot one or more learning curves.
Should at least have the index ``n'' indicating the number of training samples
used.

\item {} 
\textbf{ylim} (\emph{2-tuple, optional}) -- Vertical axis limit for learning curve plots.

\item {} 
\textbf{filename} (\emph{string, optional}) -- If given, plots are saved to indicated file path.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\emph{list} --
List with figure handles for all plots

\item {} 
\emph{list} --
List with axes handles for all plots

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsection{Visualization}
\label{classification:visualization}\label{classification:module-flamingo.classification.plot}\index{flamingo.classification.plot (module)}\index{save\_figure() (in module flamingo.classification.plot)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.plot.save_figure}\pysiglinewithargsret{\code{flamingo.classification.plot.}\bfcode{save\_figure}}{\emph{fig}, \emph{filename}, \emph{ext='`}, \emph{figsize=None}, \emph{dpi=30}, \emph{**kwargs}}{}
Save figure to file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fig} (\href{http://docs.python.org/library/functions.html\#object}{\emph{object}}) -- Figure object

\item {} 
\textbf{filename} (\href{http://docs.python.org/library/string.html\#module-string}{\emph{string}}) -- Path to output file

\item {} 
\textbf{ext} (\emph{string, optional}) -- String to be added to the filename before the file extension

\item {} 
\textbf{a Matplotlib figure as an image without borders or frames.} (\emph{Save}) -- \begin{description}
\item[{Args:}] \leavevmode
fileName (str): String that ends in .png etc.

fig (Matplotlib figure instance): figure you want to save as the image

\item[{Keyword Args:}] \leavevmode
orig\_size (tuple): width, height of the original image used to maintain
aspect ratio.

\end{description}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Utils}
\label{classification:module-flamingo.classification.utils}\label{classification:utils}\index{flamingo.classification.utils (module)}\index{aggregate\_classes() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.aggregate_classes}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{aggregate\_classes}}{\emph{Y}, \emph{aggregation=None}}{}
Aggregate class labels into a subsection of class labels

Replaces all class labels in Y with substitutes from the
dictionary \emph{aggregation}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Y} (\emph{tuple, list or np.ndarray}) -- Array containing class labels

\item {} 
\textbf{class\_aggregation} (\emph{dict, optional}) -- Dictionary containing class replacements where each key
is a the replacement value of all classes in the
corresponding list

\end{itemize}

\item[{Returns}] \leavevmode
Aggregated class labels

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_sets() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.check_sets}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{check\_sets}}{\emph{train\_sets}, \emph{test\_sets}, \emph{models=None}}{}
Checks if train sets, test sets and models have matching dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{train\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing training data corresponding to the model list.

\item {} 
\textbf{test\_sets} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of tuples containing test data corresponding to the model list.

\item {} 
\textbf{models} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List of lists with each item a trained instance of a model.

\end{itemize}

\item[{Raises}] \leavevmode
\code{ValueError} --

\end{description}\end{quote}

\end{fulllineitems}

\index{delinearize\_data() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.delinearize_data}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{delinearize\_data}}{\emph{Y}, \emph{X}}{}
De-linearizes structured label data

Transforms linearized labell data suitible for the use with LR
and SVM into structured data for the use with CRF and SSVM.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Y} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with np.ndarrays for each images with label data in one
dimensions (u*v)

\item {} 
\textbf{X} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with np.ndarray for each image with feature data in two
dimensions (u*v and feature number)

\end{itemize}

\item[{Returns}] \leavevmode
Delinearized Y data

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_classes() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.get_classes}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{get\_classes}}{\emph{Y}}{}
Get list of unique classes in Y

Returns a list of unique classes in Y with all None values removed
and regardless of the shape and type of Y.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Y} (\emph{list or np.ndarray}) -- List with np.ndarrays or np.ndarray with class labels

\item[{Returns}] \leavevmode
Array with unique class labels in Y not being None

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{int2labels() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.int2labels}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{int2labels}}{\emph{Y}, \emph{classes=None}}{}
Transforms class numbers in string class labels
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Y} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with np.ndarrays with class numbers

\item {} 
\textbf{classes} (\emph{list, optional}) -- List with unique class labels possibly in Y

\end{itemize}

\item[{Returns}] \leavevmode
Array with class labels rather than numbers

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{labels2image() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.labels2image}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{labels2image}}{\emph{Y}, \emph{seg}, \emph{classes=None}}{}
Transforms class labels and segmentation into class image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Y} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with np.ndarrays with class labels

\item {} 
\textbf{seg} (\emph{np.ndarray}) -- MxN array with superpixel numbers

\item {} 
\textbf{classes} (\emph{list, optional}) -- List with unique class labels possibly in Y

\end{itemize}

\item[{Returns}] \leavevmode
Unnormalized single-channel image of class assignments

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{labels2int() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.labels2int}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{labels2int}}{\emph{Y}, \emph{classes=None}}{}
Transforms string class labels in numbers
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{Y} (\href{http://docs.python.org/library/functions.html\#list}{\emph{list}}) -- List with np.ndarrays with class labels

\item {} 
\textbf{classes} (\emph{list, optional}) -- List with unique class labels possibly in Y

\end{itemize}

\item[{Returns}] \leavevmode
Array with class numbers rather than labels

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{linearize\_data() (in module flamingo.classification.utils)}

\begin{fulllineitems}
\phantomsection\label{classification:flamingo.classification.utils.linearize_data}\pysiglinewithargsret{\code{flamingo.classification.utils.}\bfcode{linearize\_data}}{\emph{X=None}, \emph{Y=None}}{}
Linearizes structured data

Transforms structured data suitible for the use with CRF and SSVM
into non-structrued data with a single dimension suitible for the
use with LR or SVM.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} (\emph{list, optional}) -- List with np.ndarray for each image with feature data in three
dimensions (u, v and feature number)

\item {} 
\textbf{Y} (\emph{list, optional}) -- List with np.ndarrays for each images with label data in two
dimensions (u and v)

\end{itemize}

\item[{Returns}] \leavevmode
Either linearized X, linearized Y or both are returned
depending on the input

\item[{Return type}] \leavevmode
np.ndarray or 2-tuple

\end{description}\end{quote}

\end{fulllineitems}



\section{Calibration}
\label{calibration::doc}\label{calibration:calibration}
In development.


\chapter{Command-line tools}
\label{index:command-line-tools}
Several command-line functions are supplied with the toolbox for batch processing of large datasets.
Each command-line function serves a specific part of the image analysis.
See for more information the \emph{--help} option of each command.


\section{rectify-images}
\label{index:rectify-images}\label{index:module-flamingo.rectify}\index{flamingo.rectify (module)}
Ortho-rectify images based on ground control points (GCP)
\begin{description}
\item[{Usage:}] \leavevmode
rectify-image \textless{}image\textgreater{} \textless{}gcpfile\textgreater{} {[}--dist-model=NAME{]} {[}--dist-coefs=VALUES{]} {[}--verbose{]}

\item[{Positional arguments:}] \leavevmode
image               image to be rectified
gcpfile             file containing GCP's in image (UVXYZ)

\item[{Options:}] \leavevmode\begin{optionlist}{3cm}
\item [-h, -{-}help]  
show this help message and exit
\item [-{-}dist-model=NAME]  
name of distortion model to use {[}default: OPENCV{]}
\item [-{-}dist-coefs=VALUES]  
coefficients used for distortion model {[}default: 0,0,0,0{]}
\item [-{-}size=SIZE]  
size of output figure {[}default: 30,20{]}
\item [-{-}rotation=ANGLE]  
rotate resulting image {[}default: 0{]}
\item [-{-}translation=DIST]  
translate resulting image {[}default: 0,0{]}
\item [-{-}maxdistance=DIST]  
maximum distance from origin included in plot {[}default: 1e4{]}
\item [-{-}verbose]  
print logging messages
\end{optionlist}

\end{description}


\section{classify-images}
\label{index:classify-images}\label{index:module-flamingo.classify}\index{flamingo.classify (module)}
Train, score and use classification models on image datasets.
\begin{description}
\item[{Usage:}] \leavevmode
classify-images preprocess \textless{}dataset\textgreater{} {[}--segmentate{]} {[}--channels{]} {[}--features{]} {[}--extract{]} {[}--update{]} {[}--normalize{]} {[}--relloc{]} {[}--relloc\_maps{]} {[}--images=FILE{]} {[}--config=FILE{]} {[}--overwrite{]} {[}--verbose{]}
classify-images partition \textless{}dataset\textgreater{} {[}--n=N{]} {[}--frac=FRAC{]} {[}--images=FILE{]} {[}--config=FILE{]} {[}--verbose{]}
classify-images train \textless{}dataset\textgreater{} {[}--type=NAME{]} {[}--partitions=N{]} {[}--images=FILE{]} {[}--config=FILE{]} {[}--verbose{]}
classify-images score \textless{}dataset\textgreater{} {[}--model=NAME{]} {[}--images=FILE{]} {[}--config=FILE{]} {[}--verbose{]}
classify-images predict \textless{}dataset\textgreater{} {[}--model=NAME{]} {[}--images=FILE{]} {[}--config=FILE{]} {[}--overwrite{]} {[}--verbose{]}
classify-images regularization \textless{}dataset\textgreater{} {[}--type=NAME{]} {[}--images=FILE{]} {[}--config=FILE{]} {[}--verbose{]}

\item[{Positional arguments:}] \leavevmode
dataset            dataset containing the images
image              image file to be classified

\item[{Options:}] \leavevmode\begin{optionlist}{3cm}
\item [-h, -{-}help]  
show this help message and exit
\item [-{-}segmentate]  
create segmentation of images
\item [-{-}channels]  
include channel extraction
\item [-{-}features]  
include feature extraction
\item [-{-}extract]  
extract channels/features
\item [-{-}update]  
update channels/features
\item [-{-}normalize]  
normalize channels/features
\item [-{-}relloc]  
include relative location features
\item [-{-}relloc\_maps]  
compute new relative location maps
\item [-{-}n=N]  
number of partitions {[}default: 5{]}
\item [-{-}frac=FRAC]  
fraction of images used for testing {[}default: 0.25{]}
\item [-{-}type=NAME]  
model type to train {[}default: LR{]}
\item [-{-}partitions=N]  
only train these partitions
\item [-{-}model=NAME]  
name of model to be scored, uses last trained if omitted
\item [-{-}images=FILE]  
images to include in process
\item [-{-}config=FILE]  
configuration file to use instead of command line options
\item [-{-}overwrite]  
overwrite existing files
\item [-{-}verbose]  
print logging messages
\end{optionlist}

\end{description}


\section{calibrate-camera}
\label{index:calibrate-camera}\label{index:module-flamingo.calibrate}\index{flamingo.calibrate (module)}

\chapter{File system}
\label{index:file-system}
The toolbox uses a file system structure for the analysis of datasets.
The {\hyperref[index:module-flamingo.filesys]{\code{flamingo.filesys}}} module takes care of any reading and writing of files in this file structure.
Each dataset is stored in a single directory and can consist out of the following file types:
\begin{description}
\item[{Image files}] \leavevmode
Any image file recognized by the system

\item[{Cropped image files}] \leavevmode
Names start with \emph{cropped\_}. A non-cropped version of the image file should exist.

\item[{Export files}] \leavevmode
Pickle files with data concerning an image. Each export file name has the following format: \emph{\textless{}image\_name\textgreater{}.\textless{}key\textgreater{}.pkl}.
A special type of export file is the feature file. Not all features are written to a single export file, but they
are subdivided into multiple export files depending on the feature block they belong to. The block name is added to the
export file, just before the file extension.

\item[{Log files}] \leavevmode
Pickle files with data concerning the entire dataset. Log file names can have any name.

\item[{Model files}] \leavevmode
Pickle files with a trained model. Each model file is accompanied by a meta file. Each model file name has the following format:
\emph{model\_\textless{}model\_type\textgreater{}\_\textless{}dataset\textgreater{}\_I\textless{}nr\_of\_images\textgreater{}\_B\textless{}nr\_of\_blocks\textgreater{}\_\textless{}timestamp\textgreater{}.pkl}. The corresponding meta file has \emph{meta} added to
the name, just before the file extension.

\end{description}
\phantomsection\label{index:module-flamingo.filesys}\index{flamingo.filesys (module)}\index{check\_export\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.check_export_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{check\_export\_file}}{\emph{ds}, \emph{im}, \emph{ext}}{}
Check if export file exists

\end{fulllineitems}

\index{get\_dataset\_list() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_dataset_list}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_dataset\_list}}{}{}
Get list of available datasets

\end{fulllineitems}

\index{get\_dataset\_path() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_dataset_path}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_dataset\_path}}{}{}
Get path to datasets

\end{fulllineitems}

\index{get\_export\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_export_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_export\_file}}{\emph{ds}, \emph{im=None}, \emph{ext=None}}{}
Get path to export file

\end{fulllineitems}

\index{get\_image\_list() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_image_list}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_image\_list}}{\emph{ds}}{}
Get list with all images in dataset

\end{fulllineitems}

\index{get\_image\_location() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_image_location}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_image\_location}}{\emph{ds}, \emph{im}}{}
Get absolute path to specific image in dataset

\end{fulllineitems}

\index{get\_image\_path() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_image_path}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_image\_path}}{\emph{ds}}{}
Get absolute path to images within dataset

\end{fulllineitems}

\index{get\_model\_list() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.get_model_list}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{get\_model\_list}}{\emph{ds}}{}
Get list of model files in dataset

\end{fulllineitems}

\index{has\_features() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.has_features}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{has\_features}}{\emph{ds}, \emph{im}}{}
Determine if features for image are extracted

\end{fulllineitems}

\index{is\_classified() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.is_classified}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{is\_classified}}{\emph{ds}, \emph{im}}{}
Determine if image is annotated

\end{fulllineitems}

\index{is\_segmented() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.is_segmented}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{is\_segmented}}{\emph{ds}, \emph{im}}{}
Determine if image is segmented

\end{fulllineitems}

\index{read\_default\_categories() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.read_default_categories}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{read\_default\_categories}}{\emph{ds}}{}
Read list of uniquely defined classes in dataset

\end{fulllineitems}

\index{read\_export\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.read_export_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{read\_export\_file}}{\emph{ds}, \emph{im}, \emph{ext}}{}
Read contents of export file

\end{fulllineitems}

\index{read\_feature\_files() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.read_feature_files}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{read\_feature\_files}}{\emph{ds, im, blocks={[}'extract\_blocks\_grey', `extract\_blocks\_intensity', `extract\_blocks\_mask', `extract\_blocks\_pixel', `extract\_blocks\_shape', `extract\_blocks\_intensitystatistics'{]}, ext=None}}{}
Read features from a collection of export files including only selected feature blocks

\end{fulllineitems}

\index{read\_image\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.read_image_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{read\_image\_file}}{\emph{ds}, \emph{im}, \emph{crop=True}}{}
Read image file

\end{fulllineitems}

\index{read\_log\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.read_log_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{read\_log\_file}}{\emph{ds}, \emph{keys=None}}{}
Read contents of log file

\end{fulllineitems}

\index{read\_model\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.read_model_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{read\_model\_file}}{\emph{ds}, \emph{model\_name}}{}
Read a model from export file including meta data

\end{fulllineitems}

\index{set\_dataset\_path() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.set_dataset_path}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{set\_dataset\_path}}{\emph{fpath}}{}
Set path to datasets

\end{fulllineitems}

\index{write\_export\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.write_export_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{write\_export\_file}}{\emph{ds}, \emph{im}, \emph{ext}, \emph{contents}, \emph{append=False}}{}
Write contents to export file

\end{fulllineitems}

\index{write\_feature\_files() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.write_feature_files}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{write\_feature\_files}}{\emph{ds}, \emph{im}, \emph{features}, \emph{features\_in\_block}, \emph{ext=None}}{}
Write features to a collection of export files depending on their feature block

\end{fulllineitems}

\index{write\_log\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.write_log_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{write\_log\_file}}{\emph{ds}, \emph{contents}}{}
Write contents to log file

\end{fulllineitems}

\index{write\_model\_file() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.write_model_file}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{write\_model\_file}}{\emph{ds}, \emph{model}, \emph{meta}, \emph{ext='`}}{}
Write a single model to export file including meta data

\end{fulllineitems}

\index{write\_model\_files() (in module flamingo.filesys)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.filesys.write_model_files}\pysiglinewithargsret{\code{flamingo.filesys.}\bfcode{write\_model\_files}}{\emph{ds}, \emph{models}, \emph{meta}, \emph{ext='`}}{}
Write a series of models to export files including meta data

\end{fulllineitems}



\chapter{Configuration}
\label{index:configuration}
Only the very basic options of the toolbox are exposed through the command-line functions.
For the full extent of options a configuration file is used. This configuration file is parsed by the {\hyperref[index:module-flamingo.config]{\code{flamingo.config}}} module.
The module also supplies wrappers for the automated updating of a function call based on the configuration file used.
\phantomsection\label{index:module-flamingo.config}\index{flamingo.config (module)}\index{CLASSIFICATION\_DEFAULTS (in module flamingo.config)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.config.CLASSIFICATION_DEFAULTS}\pysigline{\code{flamingo.config.}\bfcode{CLASSIFICATION\_DEFAULTS}\strong{ = \{`channels': \{`enabled': True, `methods': {[}'gabor', `gaussian', `sobel'{]}, `methods\_params': \{`frequencies': {[}0.05, 0.15, 0.25{]}, `sigmas': {[}1, 8, 15{]}, `thetas': {[}0.0, 0.785, 1.571, 2.356{]}\}\}, `segmentation': \{`remove\_disjoint': True, `extract\_contours': False, `enabled': True, `method': `slic', `method\_params': \{\}\}, `relative\_location': \{`sigma': 2, `enabled': False, `n': 100\}, `features': \{`feature\_blocks': `all', `enabled': True, `blocks\_params': \{\}\}, `score': \{\}, `partition': \{`n\_partitions': 5, `force\_split': False, `enabled': True, `frac\_test': 0.25, `frac\_validation': 0.0\}, `training': \{`partitions': `all'\}, `regularization': \{`C': {[}0.1, 1.0, 10.0, 100.0, 1000.0, 10000.0{]}, `partition': 0\}, `general': \{`model\_type': `LR', `colorspace': `rgb', `class\_aggregation': `', `model\_dataset': `'\}\}}}
Configuration constants for classification toolbox

\end{fulllineitems}

\index{get\_function\_args() (in module flamingo.config)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.config.get_function_args}\pysiglinewithargsret{\code{flamingo.config.}\bfcode{get\_function\_args}}{\emph{fcn}, \emph{cfg}, \emph{sections={[}{]}}}{}
Get relevant function arguments given a configuration file

\end{fulllineitems}

\index{parse\_config() (in module flamingo.config)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.config.parse_config}\pysiglinewithargsret{\code{flamingo.config.}\bfcode{parse\_config}}{\emph{sections={[}{]}}}{}
Wrapper for parsing config file for specific function call

\end{fulllineitems}

\index{read\_config() (in module flamingo.config)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.config.read_config}\pysiglinewithargsret{\code{flamingo.config.}\bfcode{read\_config}}{\emph{cfgfile, defaults=\{`channels': \{`enabled': True, `methods': {[}'gabor', `gaussian', `sobel'{]}, `methods\_params': \{`frequencies': {[}0.05, 0.15, 0.25{]}, `sigmas': {[}1, 8, 15{]}, `thetas': {[}0.0, 0.785, 1.571, 2.356{]}\}\}, `segmentation': \{`remove\_disjoint': True, `extract\_contours': False, `enabled': True, `method': `slic', `method\_params': \{\}\}, `relative\_location': \{`sigma': 2, `enabled': False, `n': 100\}, `features': \{`feature\_blocks': `all', `enabled': True, `blocks\_params': \{\}\}, `score': \{\}, `partition': \{`n\_partitions': 5, `force\_split': False, `enabled': True, `frac\_test': 0.25, `frac\_validation': 0.0\}, `training': \{`partitions': `all'\}, `regularization': \{`C': {[}0.1, 1.0, 10.0, 100.0, 1000.0, 10000.0{]}, `partition': 0\}, `general': \{`model\_type': `LR', `colorspace': `rgb', `class\_aggregation': `', `model\_dataset': `'\}\}}}{}
Read configuration file and update default settings

\end{fulllineitems}

\index{write\_config() (in module flamingo.config)}

\begin{fulllineitems}
\phantomsection\label{index:flamingo.config.write_config}\pysiglinewithargsret{\code{flamingo.config.}\bfcode{write\_config}}{\emph{cfgfile, defaults=\{`channels': \{`enabled': True, `methods': {[}'gabor', `gaussian', `sobel'{]}, `methods\_params': \{`frequencies': {[}0.05, 0.15, 0.25{]}, `sigmas': {[}1, 8, 15{]}, `thetas': {[}0.0, 0.785, 1.571, 2.356{]}\}\}, `segmentation': \{`remove\_disjoint': True, `extract\_contours': False, `enabled': True, `method': `slic', `method\_params': \{\}\}, `relative\_location': \{`sigma': 2, `enabled': False, `n': 100\}, `features': \{`feature\_blocks': `all', `enabled': True, `blocks\_params': \{\}\}, `score': \{\}, `partition': \{`n\_partitions': 5, `force\_split': False, `enabled': True, `frac\_test': 0.25, `frac\_validation': 0.0\}, `training': \{`partitions': `all'\}, `regularization': \{`C': {[}0.1, 1.0, 10.0, 100.0, 1000.0, 10000.0{]}, `partition': 0\}, `general': \{`model\_type': `LR', `colorspace': `rgb', `class\_aggregation': `', `model\_dataset': `'\}\}}}{}
Write configuration file

\end{fulllineitems}



\section{Example configuration}
\label{index:example-configuration}
\begin{Verbatim}[commandchars=\\\{\}]
[channels]
enabled = True
methods = [\PYGZdq{}gabor\PYGZdq{}, \PYGZdq{}gaussian\PYGZdq{}, \PYGZdq{}sobel\PYGZdq{}]
methods\PYGZus{}params = \PYGZob{}\PYGZdq{}frequencies\PYGZdq{}: [0.05, 0.15, 0.25], \PYGZdq{}sigmas\PYGZdq{}: [1, 8, 15], \PYGZdq{}thetas\PYGZdq{}: [0.0, 0.785, 1.571, 2.356]\PYGZcb{}

[segmentation]
remove\PYGZus{}disjoint = True
extract\PYGZus{}contours = False
enabled = True
method = slic
method\PYGZus{}params = \PYGZob{}\PYGZcb{}

[relative\PYGZus{}location]
sigma = 2
enabled = False
n = 100

[features]
feature\PYGZus{}blocks = all
enabled = True
blocks\PYGZus{}params = \PYGZob{}\PYGZcb{}

[score]

[train]
partitions = all

[partition]
n\PYGZus{}partitions = 5
force\PYGZus{}split = False
enabled = True
frac\PYGZus{}test = 0.25
frac\PYGZus{}validation = 0.0

[regularization]
c = [0.1, 1.0, 10.0, 100.0, 1000.0, 10000.0]
partition = 0

[general]
model\PYGZus{}type = LR
colorspace = rgb
class\PYGZus{}aggregation = 
model\PYGZus{}dataset =
\end{Verbatim}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}

\begin{thebibliography}{Gould2008}
\bibitem[Gould2008]{Gould2008}{\phantomsection\label{classification:gould2008} 
Stephen Gould, Jim Rodgers, David Cohen, Gal Elidan, Daphne Koller (2008). Multi-Class Segmentation with Relative Location Prior. International Journal of Computer Vision. \href{http://dx.doi.org/10.1007/s11263-008-0140-x}{doi:10.1007/s11263-008-0140-x}
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{f}
\item {\texttt{flamingo.calibrate}}, \pageref{index:module-flamingo.calibrate}
\item {\texttt{flamingo.classification.channels}}, \pageref{classification:module-flamingo.classification.channels}
\item {\texttt{flamingo.classification.features.blocks}}, \pageref{classification:module-flamingo.classification.features.blocks}
\item {\texttt{flamingo.classification.features.features}}, \pageref{classification:module-flamingo.classification.features.features}
\item {\texttt{flamingo.classification.features.normalize}}, \pageref{classification:module-flamingo.classification.features.normalize}
\item {\texttt{flamingo.classification.features.relativelocation}}, \pageref{classification:module-flamingo.classification.features.relativelocation}
\item {\texttt{flamingo.classification.features.scaleinvariant}}, \pageref{classification:module-flamingo.classification.features.scaleinvariant}
\item {\texttt{flamingo.classification.models}}, \pageref{classification:module-flamingo.classification.models}
\item {\texttt{flamingo.classification.plot}}, \pageref{classification:module-flamingo.classification.plot}
\item {\texttt{flamingo.classification.test}}, \pageref{classification:module-flamingo.classification.test}
\item {\texttt{flamingo.classification.utils}}, \pageref{classification:module-flamingo.classification.utils}
\item {\texttt{flamingo.classify}}, \pageref{index:module-flamingo.classify}
\item {\texttt{flamingo.config}}, \pageref{index:module-flamingo.config}
\item {\texttt{flamingo.filesys}}, \pageref{index:module-flamingo.filesys}
\item {\texttt{flamingo.rectification.plot}}, \pageref{rectification:module-flamingo.rectification.plot}
\item {\texttt{flamingo.rectification.rectification}}, \pageref{rectification:module-flamingo.rectification.rectification}
\item {\texttt{flamingo.rectify}}, \pageref{index:module-flamingo.rectify}
\item {\texttt{flamingo.segmentation.plot}}, \pageref{segmentation:module-flamingo.segmentation.plot}
\item {\texttt{flamingo.segmentation.postprocess}}, \pageref{segmentation:module-flamingo.segmentation.postprocess}
\item {\texttt{flamingo.segmentation.superpixels}}, \pageref{segmentation:module-flamingo.segmentation.superpixels}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
